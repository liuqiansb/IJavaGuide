#####  数组特点

- 存储区间连续，且内存占用严重，空间复杂度大，时间复杂度O(1)
- 优点：是随机读取效率很高，原因数组是连续（随机访问性强，查找速度快）
- 缺点：插入和删除数据效率低，因插入数据，这个位置后面的数据在内存中要往后移的，且大小固定不易动态扩展。

##### 链表特点

- 区间离散，占用内存宽松，空间复杂度小，时间复杂度O(N)
- 优点：插入删除速度快，内存利用率高，没有大小固定，扩展灵活。
- 缺点：不能随机查找，每次都是从第一个开始遍历（查询效率低）。

##### hash表特点

- 以上数组和链表，大家都知道各自优缺点。那么我们能不能把以上两种结合一起使用，从而**实现查询效率高和插入删除效率也高的数据结构**呢？答案是可以滴，那就是**哈希表**可以满足

![img](http://pics2.baidu.com/feed/3801213fb80e7becc2f5933286b2223e9a506b5d.jpeg?token=3c8eb77427b9dc750fbf19d4ba9d6859)

HashMap利用了链表和数组的双重特性，通过对key的hash运算将其放在数组对应的下标处，key值运算后相同hash的元素将形成链表结构

1. map.put(k,v)

   第一步：调用k的hash算法找到对应的数组下标

   第二步：在该下标处的链表中查找，如果存在相同值则覆盖，不存在则追加

2. map.get(k,v)

   第一步：调用k的hashCode算法得出hash值，找到数组下标

   第二部：在该下标中的链表中遍历找到该元素

3. 为何随机增删、查询效率都很高的原因是

   增删是在链表上进行的，而查找在hash运算时已经排除了一大部分，所以效率高

4. 放在hashMap集合key部分的值需要重写equals方法，因为equals默认比较的是两个对象的内存地址，进行key值对比的调用的是equals方法

##### HashMap在1.8之后的变更

> 当hash表单向链表中的元素超过8个，那么该单向链表的数据结构将变为红黑树结构，当红黑树上的节点小于6个，会重新把红黑树变成单向链表

##### 为何引入红黑树

>  当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 `O(N)`

##### HashMap死锁的产生原因，为何要引入ConcurrentHashMap

两个线程同时操作，A线程发现容量不够，准备扩容，此时B线程被调度，A挂起，B想插入新的数据，但是也发现不够，将扩容，此时A内部原来链表的将发生更改，而A原来想执行的操作也将继续进行,由此可能导致循环链表的情况,而循环链表在获取一个不存在的key的情况下将进入死循环

























