

[TOC]



#### 多线程简介

注意：在学习多线程之前先看看Thread类介绍

##### 多线程引申的问题

- 线程和进程的区别
- Thead类的常见方法
- 可以用什么手段来解决线程安全性问题
- Synchronized和Lock锁的区别
- 什么是AQS、ReentrantLock和ReentrantReadWriteLock锁
- JDK自带的线程池有哪几个，线程池的构造方法重要的参数
- 什么是死锁，怎么避免死锁
- CountDownLatch、CyclicBarrier、Semaphore是什么？
- Atomic包下的常见子类，什么是CAS，CAS会有什么问题
- ThreadLocal是什么？
- …..//

1. 多线程了解多少啊？使用多线程会有什么问题？你是怎么理解“线程安全”的？
2. 如果我现在想要某个操作等待线程结束之后才执行，有什么方法可以实现？为什么要用CountDownLatch？CountDownLatch的底层是什么？(引出AQS)
3. synchronized关键字来说一下，它的用途是什么？synchronized底层的原理是什么？
4. 线程安全的容器有哪些？(着重于ConcurrentHashMap、CopyWriteOnArrayList与其他非线程安全容器的区别以及它们的具体实现)
5. ThreadLocal你了解过吗？主要是用来干什么的？具体的源码实现原理来说一下吧
6. 产生死锁的条件是什么？我们可以如何避免死锁？(可延伸到操作系统层面上的死锁)
7. synchronized锁和ReentrantLock锁有什么区别呀？
8. 线程池你应该也看过吧，来说说为什么要用线程池。JDK默认实现了几个线程池，分别有xxx(自然地ThreadPoolExecutor构造函数的常用几个参数你也得一起说出来)
9. …

##### 多线程的适用场景

多线程不是银弹，并不是说线程越多，我们的资源利用效率就越好。执行IO操作我们线程可以适当多一点，因为很多时候CPU是相对空闲的。如果是计算型的操作，本来CPU就不空闲了，还开很多的线程就不对了（有多线程就会有线程切换的问题，线程切换都是需要耗费资源的）

- 适用于io密集型

- 不适用于cpu密集型

##### 线程安全

- 如果是集合，我们可以考虑一下juc包下的集合类。
- 如果是数值/对象，我们可以考虑一下atomic包下的类。
- 如果是涉及到线程的重复利用，我们可以考虑一下是否要用线程池。
- 如果涉及到对线程的控制（比如一次能使用多少个线程，当前线程触发的条件是否依赖其他线程的结果），我们可以考虑CountDownLatch/Semaphore等等
- 如果synchronized无法满足你，我们可以考虑lock包下的类

#### juc框架体系

##### concurrent

- tools
- locks
- collections
- executor
- atomic

##### tools

- CountDownLatch  *`(常用)

  > 阻塞当前线程，直到计数器值为0

  1. 某一线程在开始运行前等待n个线程执行完毕。将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载

     ```java
     public class CountDownLatchTest {
         @Test
         public void test1(){
             ExecutorService service = Executors.newFixedThreadPool(3);
             final CountDownLatch latch = new CountDownLatch(3);
             for(int i=0;i<3;i++){
                 Runnable runnable = new Runnable() {
                     @Override
                     public void run() {
                         System.out.println(Thread.currentThread().getName()+"开始");
                         try {
                             Thread.sleep(2000L);
                         }catch (InterruptedException e){
                             e.printStackTrace();
                         }
                         System.out.println(Thread.currentThread().getName()+"结束");
                         latch.countDown();
                     }
                 };
                 service.execute(runnable);
             }
             try{
                 latch.await();
             }catch (InterruptedException e){
                 e.printStackTrace();
             }
             System.out.println("主线程开始运行~");
     
         }
     }
     ```

  2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的CountDownLatch(1)，将其计算器初始化为1，多个线程在开始执行任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。

     ```java
     public void test2(){
             ExecutorService service = Executors.newFixedThreadPool(3);
             final CountDownLatch childLock = new CountDownLatch(1);
             final CountDownLatch mainLock = new CountDownLatch(3);
             for(int i=0;i<3;i++){
                 Runnable runnable = new Runnable() {
                     @Override
                     public void run() {
                         try{
                             childLock.await();	// 阻塞子线程
                         }catch (InterruptedException e){
                             e.printStackTrace();
                         }
                         System.out.println(Thread.currentThread().getName()+"开始");
                         mainLock.countDown(); // 唤醒主线程
                     }
                 };
                 service.execute(runnable);
             }
             try {
                 Thread.sleep(2000L);
             }catch (InterruptedException e){
                 e.printStackTrace();
             }
             childLock.countDown();	  // 唤醒前面定义的子线程
             try {
                 mainLock.await();	 // 阻塞主线程
             }catch (InterruptedException e){
                 e.printStackTrace();
             }
             System.out.println("主线程结束");
     }
     ```

  3. 引申，CountDownLatch和join的区别

     - CountDownLatch更加的灵活，它可以完全控制某个线程运行与停顿，实现线程在各个阶段相互唤醒

- CyclicBarrier  *`(常用)`*

  > 实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作，循环拦截

  ```java
  public void test3() throws InterruptedException {
          ExecutorService service = Executors.newFixedThreadPool(4);
          final CyclicBarrier barrier = new CyclicBarrier(4);
          final CountDownLatch mainLock = new CountDownLatch(4);
          for(int i=0;i<4;i++){
              Runnable runnable = new Runnable() {
                  @SneakyThrows
                  @Override
                  public void run() {
                      barrier.await(); // 调用将线程阻塞，并且将计数器-1，计数器为0时，唤醒全部线程,并将计数器重新设置为初始值
                      System.out.println(Thread.currentThread().getName()+"开始第一步");
                      barrier.await();
                      System.out.println(Thread.currentThread().getName()+"开始第二步");
                      barrier.await();
                      System.out.println(Thread.currentThread().getName()+"开始第三步");
                      mainLock.countDown();
                  }
              };
              service.execute(runnable);
          }
          mainLock.await();
          System.out.println("主线程运行");
      }
  ```

  

- Semaphore  *`(常用)`*

  > Semaphore 就是synchronized 的加强版，作用是控制线程的并发数量，限流利器

  ```java
  public class SemaphoreTest {
      @Test
      public void test() throws InterruptedException {
          final Semaphore semaphore = new Semaphore(3);
          ExecutorService executorService = Executors.newFixedThreadPool(4);
          final CountDownLatch mainLock = new CountDownLatch(4);
          for(int i=0;i<4;i++){
              Runnable runnable = new Runnable() {
                  @SneakyThrows
                  @Override
                  public void run() {
                      semaphore.acquire();
                      System.out.println(Thread.currentThread().getName()+"即将进入休眠!");
                      Thread.sleep(5000L);// 第四个线程需要前面任意一个线程先释放一个锁
                      semaphore.release();
                      mainLock.countDown();
                  }
              };
              executorService.execute(runnable);
  
          }
          mainLock.await();  // 避免主线程结束
      }
  }
  ```

- Executors

  > 控制线程的启动、执行和关闭，可以简化并发编程的操作

  Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。

  1. Future

     　Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，**该方法会阻塞**直到任务返回结果

     ```java
     public interface Future<V> {
     	// cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false
         boolean cancel(boolean mayInterruptIfRunning); 
         // 任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。
         boolean isCancelled();
         // 任务是否已经完成，若任务完成，则返回true；
         boolean isDone();
         // 获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；
         V get() throws InterruptedException, ExecutionException;
         // 获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。
         V get(long timeout, TimeUnit unit)
             throws InterruptedException, ExecutionException, TimeoutException;
     }
     ```

     ![img](https://img-blog.csdn.net/20180606202542500)

     ```java
     public void test() throws ExecutionException, InterruptedException {
             ExecutorService executorService = Executors.newCachedThreadPool();
             Future<Integer> result = executorService.submit(new Callable<Integer>() {
                 @Override
                 public Integer call() throws Exception {
                     System.out.println("子线程正在计算!");
                     Thread.sleep(2000L);
                     int sum = 0;
                     for (int i = 0; i < 100; i++) {
                         sum += i;
                     }
                     return sum;
                 }
             });
             // 关闭线程池，但是只是在线程池中所有线程都运行完毕的时候关闭
             executorService.shutdown();
             System.out.println(result.get());
         }
     ```

  2. CompletionService

     主要用于解决多个Future阻塞主线程,不能及时处理返回值问题

     ```java
     /**
      *	传统方式：多个future依次阻塞主线程，导致最快完成的future未能及时处理
      **/
     
     public class ReentrantLockTest {
         @Test
         public void test3() throws InterruptedException{
             ExecutorService executor =
                     Executors.newFixedThreadPool(3);
             BlockingQueue<Integer> bq =
                     new LinkedBlockingQueue<>();
             Future<Integer> future1 = executor.submit(()->{
                 TimeUnit.SECONDS.sleep(100);
                 return 1;
             });
             Future<Integer> future2 = executor.submit(()->{
                 TimeUnit.SECONDS.sleep(10);
                 return 2;
             });
             Future<Integer> future3 = executor.submit(()->{
                 TimeUnit.SECONDS.sleep(1);
                 return 3;
             });
             // 按照传统的直接future1.get()写法，将会阻塞主线程，如果future1执行较久，则后面的future2和future3都得不到及时处理
             executor.execute(()-> {bq.put(future1.get());});
             executor.execute(()-> {bq.put(future2.get());});
             executor.execute(()-> {bq.put(future3.get());});
             // 此处使用LinkedBlockingQueue队列来实现依次获取
             for (int i = 0; i < 3; i++) {
                 Integer result = bq.take();
                 System.out.println(result);
             }
         }
     }
     ```

     ```java
     // 使用CompletionService来实现多future的顺序获取
     public class CompletionServiceTest {
         public void test4() throws InterruptedException, ExecutionException {
             ExecutorService executor =
                     Executors.newFixedThreadPool(3);
             CompletionService<Integer> cs = new
                     ExecutorCompletionService<>(executor);
             cs.submit(()->{
                 TimeUnit.SECONDS.sleep(3);
                return 1;
             });
             cs.submit(()->{
                 TimeUnit.SECONDS.sleep(2);
                 return 2;
             });
             cs.submit(()->{
                 TimeUnit.SECONDS.sleep(1);
                 return 3;
             });
             for (int i = 0; i < 3; i++) {
                 Integer integer = cs.take().get();
                 System.out.println(integer); // 将依次获取到future里面的值
             }
         }
     }
     ```

     

- Exchanger

  > 线程通讯神器，指定两个线程之间特定位置的变量值进行交换，借此完成线程通讯

  ```java
  public class ExchangerTest {
      @Test
      public void test() throws InterruptedException {
          final Exchanger<String> objectExchanger = new Exchanger<>();
          final CountDownLatch mainLock = new CountDownLatch(2);
          Thread thread = new Thread(new Runnable() {
              @SneakyThrows
              @Override
              public void run() {
                  String v = objectExchanger.exchange(null);
                  System.out.println(exchange+Thread.currentThread().getName());
                  mainLock.countDown();
              }
          });
          Thread thread2 = new Thread(new Runnable() {
              @SneakyThrows
              @Override
              public void run() {
                  String v = "lose";
                  String exchange = objectExchanger.exchange(v);
                  mainLock.countDown();
              }
          });
          thread.start();
          thread2.start();
          mainLock.await(); // 主进程锁
      }
  }
  ```

  



##### locks

- Lock

  - ReentrantLock

    ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取，ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的

    1. 公平锁  线程依次排队获取锁
    2. 非公平锁 不管自己是不是在队列的开头都会获取锁。

    与synchronized的区别

    1. synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活,ReentrantLock也是独占锁，**加锁和解锁的过程需要手动进行**，不易操作，但非常灵活。
    2. synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁
    3. synchronized不可响应中断，一个线程获取不到锁就一直等着；**ReentrantLock可以相应中断**。

    ReentrantLock最主要的特性是可以实现公平锁机制，即在锁上等待时间最长的线程将获得锁的使用权

    ```java
    // 简单使用
    public class ReentrantLockTest {
        private Lock lock = new ReentrantLock();
        @Test
        public void test() throws InterruptedException {
            lock.lock();
            System.out.println(Thread.currentThread().getName()+"获取了锁");
            TimeUnit.SECONDS.sleep(2);
            lock.unlock();
            System.out.println(Thread.currentThread().getName()+"释放锁");
        }
    }
    ```

    ```java
    // 公平锁
    public class ReentrantLockTest {
        private Lock lock = new ReentrantLock(true); // 参数为true将使用公平锁,默认为非公平锁
        private CountDownLatch countDownLatch = new CountDownLatch(12);
        @Test
        public void test2() throws InterruptedException {
            new Thread(this::run,"线程A").start();
            new Thread(this::run,"线程B").start();
            new Thread(this::run,"线程C").start();
            new Thread(this::run,"线程D").start();
            new Thread(this::run,"线程E").start();
            new Thread(this::run,"线程F").start();
            countDownLatch.await();
        }
        private void run(){
            for(int i=0;i<2;i++){
                try {
                    lock.lock();       // 各个线程会依次获取锁，等待时间相同
                    System.out.println(Thread.currentThread().getName()+"获取锁");
                    TimeUnit.SECONDS.sleep(2);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }finally {
                    lock.unlock();
                    countDownLatch.countDown();
                }
            }
        }
    }
    ```

  - ReentrantReadWriteLock.ReadLock

    ReentrantLock是互斥排他锁，同一时间只能有一个线程在执行任务，ReentrantLock支持锁的重入功能，虽然保证了线程的安全性，但是效率不高，实际上应该是写操作互斥，读操作共享。而jdk提供了读写锁ReentrantReadWriteLock。**灵活的控制锁是否互斥**

  - ReentrantReadWriteLock.WriteLock

    ```java
    /**
     * 两个线程都使用读锁的时候不互斥,将同时进行
     */
    public class ReentrantReadWriteLockTest {
        private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        private CountDownLatch countDownLatch = new CountDownLatch(2);
        @Test
        public void test() throws InterruptedException {
            Thread thread1 = new Thread(this::read,"t1");
            Thread thread2 = new Thread(this::read,"t2");
            thread1.start();
            thread2.start();
            countDownLatch.await();
        }
        public void read(){
            try {
                lock.readLock().lock();
                System.out.println(Thread.currentThread().getName()+"START");
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName()+"END");
            }catch (InterruptedException e){
                e.printStackTrace();
            }finally {
                lock.readLock().unlock();
                countDownLatch.countDown();
            }
        }
    }
    // return t1START t2START t2END t1END
    ```

    ```java
    /**
     * 两个线程都使用写锁的时候将互斥进行
     */
    public class ReentrantReadWriteLockTest {
        private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        private CountDownLatch countDownLatch = new CountDownLatch(2);
        @Test
        public void test2() throws InterruptedException {
            Thread thread1 = new Thread(this::read,"t1");
            Thread thread2 = new Thread(this::write,"t2");
            thread1.start();
            thread2.start();
            countDownLatch.await();
        }
        public void write(){
            try {
                lock.writeLock().lock();
                System.out.println(Thread.currentThread().getName()+"START");
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName()+"END");
            }catch (InterruptedException e){
                e.printStackTrace();
            }finally {
                lock.writeLock().unlock();
                countDownLatch.countDown();
            }
        }
    }
    // return t1START t1END t2START t2END
    
    // 注意:两个线程分别使用读锁和写锁会互斥，即只要写锁出现便会互斥
    ```

- Condition

  Condition就是在使用Lock类时，替代wait,notify,notifyAll的工具类

  ```java
  public class ConditionTest {
      public Lock lock = new ReentrantLock();
      public Condition condition = lock.newCondition();
      public CountDownLatch countDownLatch = new CountDownLatch(2);
      @Test
      public void test() throws InterruptedException {
          ExecutorService executorService = Executors.newFixedThreadPool(2);
          executorService.execute(new Runnable() {
              @SneakyThrows
              @Override
              public void run() {
                  lock.lock();
                  System.out.println(Thread.currentThread().getName()+"获取锁");
                  condition.await(); // 进入等待状态
                  System.out.println(Thread.currentThread().getName()+"重新唤醒");
                  lock.unlock();
                  countDownLatch.countDown();
              }
          });
  
          executorService.execute(new Runnable() {
              @SneakyThrows
              @Override
              public void run() {
                  lock.lock();
                  System.out.println(Thread.currentThread().getName()+"获取锁");
                  Thread.sleep(2000L);
                  condition.signal();	// 唤醒其他等待线程
                  System.out.println(Thread.currentThread().getName()+"发出信号了");
                  lock.unlock();
                  countDownLatch.countDown();
              }
          });
          countDownLatch.await();
      }
  }
  ```

  

- ReadWriteLock

  - ReentrantReadWriteLock

- LockSupport

  LockSupport是一个编程工具类，主要是为了阻塞和唤醒线程用的

  1. 基本方法

     ```java
     (1) 阻塞当前线程
     public static void park(Object blocker);
     (2) 暂停当前线程，有超时时间
     public static void parkNanos(Object blocker,long nanos);
     (3) 暂停当前线程直到某个时间
     public static void parkUntil(Object blocker,long deadline);
     (4) 无限暂停当前线程
     public static void park();
     (5) 暂停当前线程
     public static void parkNanos(long nanos);
     public static void parkUntil(long deadline);
     (7) 回复当前线程
     public static void unpark(Thread thread);
     public static Object getBlocker(thread thread);
     ```

  2. 与wait/notify对比

     ```java
     public class LockSupportTest {
         @Test
         public void test(){
             Thread thread = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     System.out.println("线程停止");
                     LockSupport.park();
                     System.out.println("线程启动");
                 }
             });
             thread.start();
             // 可以指定线程唤醒，而notify是随机的
             // 无需获取到锁对象，直接调用静态方法
             LockSupport.unpark(thread); 
         }
     }
     ```

     

![20190326163405951](G:\学习文档\IJavaGuide\juc\20190326163405951.png)





##### collections

- Queue
  - ConcurrentLikedQueue
  - BlockingQueue
    - ArrayBlockingQueue
    - DelayQueue
    - LinkedBlockingQueue
    - ProorityBlockingQueue
    - SynchronousQueue
  - Deque
    - ArrayDeQue
    - IdentityLinkedList
    - BlockingDeque
      - LinkedBlockingDeque
  
- CopyOnWriteArrayList   *`(常用)`*

  根据读写锁的思想，读锁与读锁之间不冲突。但是读操作会受到写操作的阻碍，当写操作发生时，读就必须等待。否则可能读到不一致的数据。同时，如果读操作正在进行，程序也不能进行写入。为了将读取的性能发挥到极致，jdk中提供了CopyOnWriteArrayList类，读取不加锁

  **原理：写入的时候进行一次自我复制，完成后才替换**

- CopyOnWriteArraySet
- ConcurrentSkipListSet
- ConcurrentMap
  - ConcurrentHashMap  *`(常用)`*
  - ConcurrentNavigableMap
    - ConcurrentSkipListMap

![20190326163507254](G:\学习文档\IJavaGuide\juc\20190326163507254.png)

##### executor

- Future
  - RunnableFuture
    - RunnableScheduledFuture
    - FutureTask
  - ScheduledFuture
- Callable
- Executor
  - ExecutorService
    - SecheduledExecutorService
      - ScheduledThreadPoolExecutor
    - ThreadPoolExecutor
- CompletionService
  - ExecutorCompletionService
- RejectedExecutionhandler
  - ThreadPoolExecutor.DisCardPolicy
  - ThreadPoolExecutor.DiscardOldestPolicy
  - ThreadPoolExecutor.CallerRunsPolicy
  - ThreadPoolExecutor.AbortPolicy
- TimeUnit

![20190326163550504](G:\学习文档\IJavaGuide\juc\20190326163550504.png)

##### atomic

- AtomicBoolean
- AtomicInteger
- AtomicReference

![20190326163611266](G:\学习文档\IJavaGuide\juc\20190326163611266.png)





















