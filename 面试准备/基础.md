##### HashMap

```
1.hashmap的容量为2的指数次幂，比如传个13，会转成16
2.hashmap使用hash&(length-1)来替代h%length，在计算机中加法>乘法>除法>取模
```

- **为什么要是2的指数次幂？**

  当length的长度是2的指数次幂的时候，***hash&(length-1)可以用来替代hash%length***，如length=0000 0000 0000 1111,那么hash值不管如何，计算后的下标也不可能大于15

- **为什么加载因子是0.75**

  当数组的百分之75的下标都出现了hash碰撞后，就会扩容，所以高加载因子增大了空间利用率，低加载因子增大了查询时间效率，**这是一种对于空间复杂度和时间复杂度的折中**

- 为什么1.8后链表达到8个元素后转为红黑树？

  **泊松分布**，统计学知识，在加载因子是0.75的时候，重复hash碰撞的概率将会指数降低，而重复碰撞了8次的概率达到了0.00000006，基本接近于0了，也就是**产生红黑树的几率根本不大**

- **1.7hashmap扩容链表环的产生原因？**

  多线程扩容的场景：指针问题，第二个线程进行了三次循环

  ![image-20200913203935958](C:\Users\皿煮国的潜逃败类\AppData\Roaming\Typora\typora-user-images\image-20200913203935958.png)

  

- **1.8如何减少hash碰撞，如何避免链表环形成，如何做到扩容无需rehash**

  在1.7的hash运算中，只有hash的低四位才参与&运算这样碰撞的概率极大，所以在1.8的优化中，高位也将参与运算

  ```
  # 这种做法只是为了减少hash碰撞，但是相同hash
  h: 		            1111 1111 1111 1111 1010 0000 1111 1010
  
  h>>>16:             0000 0000 0000 0000 1111 1111 1111 1111   # 获取hashcode的高16位，>>>16 右移16位
  h=h^h>>>16:         1111 1111 1111 1111 0101 1111 0000 0101   # hashcode与hashcode的高16位进行异或运算得到新的hashcode
  
  table.length-1:     0000 0000 0000 0000 0000 0000 0000 1111
  
  h&(table.length-1): 0000 0000 0000 0000 0000 0000 0000 0101  # 将新的hashcode与原来的hashcode进行与运算,1.7中就做了这一步
  
  
  # 相同链表得节点最终hash的后四位一定是一致的,也就是h^h&&&16的值必然相等
  # 在1.8的迁移中，迁移后的节点必然存在于原索引或者原索引+oldCap位置
  
  
  h=h^h>>>16    : 	1111 1111 1111 1111 0101 1111 0000 0101
  table.length-1: 	0000 0000 0000 0000 0000 0000 0000 1111   #旧表索引   
  
  旧表位置：		 	 0000 0000 0000 0000 0000 0000 0000 0101
  
  newTable.length-1 : 0000 0000 0000 0000 0000 0000 0001 1111  # 新表索引
  
  新表位置:			  0000 0000 0000 0000 0000 0000 0000 0101
  
  结论：旧表位置取决于高位运算后的最终hash的后4位，而新表位置取决于后5位，所以第五位要么和之前一样是0 要么变成了1 
  所以移后的节点必然存在于原索引或者（原索引+oldCap）位置
  ```

  在1.8的扩容中，hashmap的扩容直接把链条上的节点截做两段，然后分别放到原索引和(原索引+oldcap)的位置，也就是更改后并未调整节点顺序，所以不会出现死循环问题，但是这仍然改不了hashmap不是并发安全的问题

- **ConcurrentHashMap线程安全吗？什么是分段锁**